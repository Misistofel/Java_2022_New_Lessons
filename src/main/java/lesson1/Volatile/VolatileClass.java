package lesson1.Volatile;

public class VolatileClass {
  public volatile long x = 2222222222222222222L;

  public static void main(String[] args) {

  }
  //У процесі роботи багатопоточного докладання різні потоки можуть кешувати значення змінних
  //Можлива ситуація, коли один потік змінив значення змінної, а другий не побачив цієї зміни,
  // тому що працював зі своєю кешованою копією змінної.
  //Звичайно, наслідки можуть бути серйозними. Наприклад, мова йде про
  // баланс банківської картки, який раптом почав рандомно скакати туди-сюди

  /*Java операції читання і запису полів всіх типів, крім long і double, є атомарними.
Що таке атомарність?
Ну, наприклад, якщо ти в одному потоці змінюєш значення змінної int, а в іншому потоці читаєш значення цієї змінної,
ти отримаєш або її старе значення, або нове - те, що вийшло після зміни в потоці 1. Ніяких проміжних варіантів там з'явитися
 не може.
Але з long та double це не працює. Чому?
Через кросплатформність.
Принцип Java - "написано одного разу - працює скрізь"? Це і є кроссплатформенність. Тобто Java-програма запускається на абсолютно
 різних платформах. Наприклад, на операційних системах Windows, різних варіантах Linux або MacOS, і скрізь ця програма стабільно
 працюватиме.
long і double - "найважливіші" примітиви в Java: вони важать по 64 біти. І в деяких 32-бітних платформах просто не реалізовано
 атомарність читання та запису 64-бітних змінних. Такі змінні читаються та записуються у дві операції. Спочатку в змінну
 записуються перші 32 біти, потім ще 32.
Перший потік почне запис цього числа змінну, і спочатку запише перші 32 біта:
100000000000000000000000000000
а потім другі 32:
00000000000000000000000000001
У десятковій системі це число дорівнює 2147483648.
Тобто ми лише хотіли записати число 9223372036854775809 в змінну, але через те, що ця операція на деяких платформах є не
атомарною, у нас з нізвідки виникло «ліве», непотрібне нам число 2147483648, і невідомо як воно вплине . Другий потік просто
прочитав значення змінної до того, як воно остаточно записалося, тобто перші 32 біти він побачив, а другі 32 біти - ні.
Ці проблеми, звичайно, виникли не вчора, і в Java вони вирішуються лише одним ключовим словом — volatile.
Якщо ми оголошуємо в програмі якусь змінну, зі словом volatile
Вона завжди буде атомарно читатись і записуватись. Навіть якщо це 64-розрядні double або long.
Java-машина не поміщатиме її в кеш. Тому ситуація, коли 10 потоків працюють зі своїми локальними копіями виключена.*/
}
